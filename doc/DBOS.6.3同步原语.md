同步原语主要是在设计进程管理部分时所需要解决的并发互斥的问题，对于进程要访问的临界区的资源，我们需要控制访问权限，避免多个进程同时访问同一个临界区的资源，同时我们还有必要实现能够为操作提供原子性的功能，以保证当前的操作在执行的过程中不会被打断，比如像一些进程的启动函数，我们必须保证这个进程在加入进程链表进行调度之前其启动函数已经执行完成了，还有等等诸多情形需要同步原语的作用。<br />我们目前操作系统内核的同步原语主要提供了自旋锁、互斥锁和信号量这三个模块，基于这三个模块，我们当然可以实现更高级的同步原语，不过有了这三个已经足够应当绝大多数的场景了，并且信号量所能支持和扩展的功能是相当大的。<br />首先是最简单的自旋锁`spinlock`，自旋锁机制是一个比较简单的基于忙等待方式的锁机制，本质就是通过内存中的一个整数来实现锁，任何进程进入临界区前都会检查这个整数是否为0，为0则可以进入临界区，并且将其设置为1，加锁，然后这个锁就进入忙等待的过程，直到有进程给它解锁，具体实现借助gcc编译器提供的原语指令即可，可以参考代码实现。<br />自旋锁有一个弊端就是它是不加以权限管理的，也就是某个进程在当前临界区加锁了，但是其他任意一个进程都可以擅自解锁从而进入这个临界区，如果是这种情况的话，那么锁对于临界区的保护机制就没有什么作用了，因此互斥锁`mutex`就有了它的应用场景。互斥锁实现的关键就是在自旋锁的基础上增加了`belong_pid`这一属性来区分当前这个锁是属于哪个进程的，当确定了所属进程之后，这个锁的操作比如解锁等就只能由所属的进程来实现，其他进程尝试解锁是无法成功的，不过它的等待逻辑仍然是像自旋锁那样的忙等待，不过这个也可以进行改进。<br />最后一个也是最重要的一个就是信号量`semaphore`，信号量的机制本身也是比较简单的，它其实就是用于进程间传递信号的一个整数值，理论上只可以进行三种操作：初始化、递减和增加，其中递减操作就是熟悉的`wait`操作，而增加操作就是`signal`操作，前者用来阻塞一个进程，后者用来唤醒一个进程。对于阻塞策略，本内核的信号量采取的是阻塞队列的结构，即先进先出（FIFO），也就是强信号量，操作系统理论上能够证明强信号量是可以保证不会饥饿的，也就是不会出现进入阻塞状态的进程一直得不到唤醒。实现逻辑就是经典的信号量实现逻辑，同时为信号量设计了进程的等待队列这一数据结构，当进程被阻塞进入队列时，它的执行状态也会相应变成阻塞态，这个状态不会被调度器调度，只有它被唤醒离开等待队列时，才会改变状态为就绪态。就这样通过进程调度的协助顺利实现了信号量机制。信号量机制在本内核设计中还有一个重要的作用就是实现父进程等待子进程的系统调用，这也就是为什么进程控制块的结构体中有`SEMAPHORE* sem`这样一个属性。<br />By：谢骏鑫
