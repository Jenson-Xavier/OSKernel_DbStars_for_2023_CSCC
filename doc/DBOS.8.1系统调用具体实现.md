这里主要简单给出本内核在初赛要求下实现的30个系统调用的大致逻辑，由于篇幅不支持将这么多个系统调用都非常清楚地说明并且解释明白其中涉及的逻辑，因此这里只是用简短干练的语言去大致描述一下每个系统调用的实现逻辑，并且在具体代码中基本每个系统调用实现中都给出了详实具体的注释，解释了其中的实现逻辑和细节等。<br />`SYS_getcwd`：获取当前工作目录的系统调用，获取得到当前的进程，通过这个进程结构体访问到其中的当前工作目录的成员即可。<br />`SYS_pipe2`：暂时还没有实现。<br />`SYS_dup`：复制文件描述符的系统调用，获取得到当前的进程，进而得到它的文件描述符的`file_object`对象，通过对应的管理器提供的接口调用`duplicate_fo`函数得到复制的文件对象，直接将其插入到当前进程打开的文件描述符表之后即可。<br />`SYS_dup3`：与前一个复制文件描述符的系统调用不同的是，这个系统调用增加了指向新文件描述符的过程，实现逻辑也是简单的，通过相应的接口进行复制和插入即可，注意一些情况像文件描述符已经存在的判断和特殊处理即可。<br />`SYS_chdir`：切换工作目录的系统调用，获取得到当前的进程，允许内核态访问用户态的数据，重新设置当前进程的当前工作目录的成员即可。<br />`SYS_openat`：打开或创建一个文件的系统调用，主要根据传入的参数和`flags`标志信息来判断是要创建一个文件或者目录还是打开一个文件，然后调用文件系统提供的对应的接口即可，注意打开一个文件之后需要在对应的进程创建相关的文件描述符。<br />`SYS_close`：关闭一个文件描述符的系统调用，获取得到当前的进程，通过传入的文件描述符`fd`得到对应的文件对象，通过管理器提供的接口调用`close_fo`即可。<br />`SYS_getdents64`：<br />`SYS_read`：从一个文件描述符中读取的系统调用，获取得到当前的进程，通过传入的文件描述符`fd`得到对应的文件对象，通过管理器提供的接口调用`read_fo`即可。<br />`SYS_write`：从一个文件描述符中读取的系统调用，获取得到当前的进程，通过传入的文件描述符`fd`得到对应的文件对象，通过管理器提供的接口调用`write_fo`即可。<br />`SYS_linkat`：暂时还没有实现。<br />`SYS_unlinkat`：暂时还没有实现。<br />`SYS_mkdirat`：创建目录的系统调用，根据传入的参数和文件系统的接口找到对应的目录位置进行创建目录的调用即可。<br />`SYS_umount2`：卸载文件系统的系统调用，由于文件系统已经被挂载并且不可以被卸载，直接返回0即可。<br />`SYS_mount`：挂载文件系统的系统调用，由于文件系统已经被挂载，因此不能再被挂载一次，直接返回0即可。<br />`SYS_fstat`：获取文件状态的系统调用，获取得到当前的进程，通过传入的文件描述符`fd`得到对应的文件对象，进而得到具体打开的文件属性，然后依照要填充的结构体依次填充即可。<br />`SYS_clone`：创建一个子进程系统调用，通过传入的`stack`参数是否非空来决定是进行`fork`的调用还是进程`clone`的系统调用，如果`stack`参数为空，那么当前系统调用的执行逻辑和`fork`一致，子进程和父进程执行一段相同的二进制代码，关键就是做好进程空间资源的内存层面的拷贝；反之则和`clone`调用一致，本大赛的`clone`的调用就是让子进程去执行一个特定的函数，父进程继续执行直到回收即可。<br />`SYS_execve`：执行一个指定的程序的系统调用，关键就是根据传入的路径参数打开得到对应的文件，然后通过解析ELF文件格式创建进程的接口去创建并运行相关的进程即可，注意执行了这个系统调用之后此进程称为父进程，需要等待子进程执行完毕负责回收了子进程才可以退出。<br />`SYS_wait4`：等待进程改变状态的系统调用，其实就是用来实现父进程等待子进程并回收的系统调用，主要通过同步原语中所属的信号量来实现，当父进程有需要等待执行完毕的子进程时，自己的信号量发出`wait`进程阻塞队列，当子进程运行结束被父进程回收时会触发`signal`信号解除阻塞。<br />`SYS_exit`：触发进程终止的系统调用，通过进程管理器接口提供的相关接口获取当前正在进行的进程，然后调用终止并且回收进程的接口即可。<br />`SYS_getppid`：获取父进程PID的系统调用，获取当前的进程，然后得到指向其父进程的进程结构体指针，返回对应的`pid`即可。<br />`SYS_getpid`：获取进程PID的系统调用，获取当前的进程，返回其`pid`即可。<br />`SYS_brk`：修改数据段大小的系统调用，通过进程的`HMR* heap`属性来实现，调用其指向的`resize`方法即可。<br />`SYS_munmap`：暂时还没有实现。<br />`SYS_mmap`：暂时还没有实现。<br />`SYS_times`：获取进程时间的系统调用，获取当前的进程，根据其结构体中一直有实时维护和更新的与时间相关的成员属性即可，具体细节在本函数的实现代码中有很详细的注释。<br />`SYS_uname`：打印系统信息的系统调用，对传入的结构体参数依次赋值即可。<br />`SYS_sched_yield`：让出调度器的系统调用，直接调用`ProcessManager`类提供的`rest_proc`成员方法即可。<br />`SYS_gettimeofday`：获取时间的系统调用，获取当前的处理器时钟，设置相应的成员和属性值即可。<br />`SYS_nanosleep`：执行线程睡眠的系统调用，获取进程要睡眠的处理器时钟数，通过内核全局态的信号量去阻塞当前进程，由于是通过全局信号量去阻塞的，因此通过在调度器和切换进程状态增加一些额外的处理和判断实现自唤醒功能，从而实现进程的指定时间的睡眠。<br />By：谢骏鑫
