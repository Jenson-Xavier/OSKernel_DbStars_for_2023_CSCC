进程调度是操作系统内核进行进程管理的核心功能，我们都知道，要能够正确进行进程调度的关键就是做好进程上下文的切换和保存工作，我们目前内核进行进程调度逻辑的核心算法就是RR时间片轮转调度算法，通过中断的接口来完成进程调度的功能。<br />如上一节所见，每个进程结构体中都有`TRAPFRAME* context`这个属性，而`TRAPFRAME`结构就是在RISC v结构下的通用寄存器组和控制状态寄存器组的集合，本质就是这些寄存器构成了进程的上下文，在进程调度时间片轮转调度算法，我们通过时钟中断来给每个运行的进程提供一个固定的时间片，每当这个时间片用完了，触发的时钟中断就会执行进程调度器，而进程调度器的逻辑就是找到一个正在等待的且进程状态为就绪态的进程，将它保存的`TRAPFRAME* context`属性作为中断例程的返回值，而将当前的`TRAPFRAME`（不妨称之为中断帧/陷入帧）重新赋值给刚刚用完时间片的进程的`context`属性，这样就成功完成了进程的上下文切换从而实现进程调度了。<br />而调度的核心逻辑是在函数`TRAPFRAME* proc_scheduler(TRAPFRAME* context)`中实现的，进入对应的代码中可以看到，目前的执行逻辑就是通过顺次遍历链表来找到下一个可执行的进程，也是我们称之为时间片轮转调度的原因。之前提到我们的进程保留了很多灵活且可扩展的设计，这就是一个充分的体现，我们可以通过增加相关的数据结构和一些指标属性到进程结构体中并且做好正确的维护和更新，那么我们只需要更改这个函数执行的逻辑，就完全可以实现像其他经典的进程调度算法：先来先服务（FCFS）调度算法、改进的轮转调度算法（虚拟轮转法VRR）、最短进程优先（SPN）调度算法、最短剩余时间（SRT）调度算法、最高响应比优先（HRRN）调度算法、反馈（动态优先级）法等。<br />同时基于这样的结构和设计，我们也可以基于底层的RISC v指令集架构来便捷地实现我们进程的启动函数，也就是让一个程序能在操作系统内核上执行起来，不仅仅需要创建一个进程，并且将这个程序的资源进行正确的分配，还需要设置启动和跳转，以及对于内核进程和用户进程设置不同的权限、启动地址、资源空间等。充分利用了中断和指令集的架构来进行设计，使得我们在实现这些功能时变得更加统一和方便。代码中除了从ELF创建进程的函数单独处理了，其他几个创建进程（包括了启动这个进程，创建的进程就能正常进行调度和执行了）的函数接口声明如下。
```cpp
// 创建内核进程的通用全局函数
proc_struct* CreateKernelProcess(int (*func)(void*), void* arg, char* name);


// 创建用户进程的全局函数(内核嵌入用户进程映像实现的)
proc_struct* CreateUserImgProcess(uint64 img_start, uint64 img_end, char* name = (char*)"");


// 从特定启动函数创建用户进程(内核嵌入用户进程映像实现的)
proc_struct* CreateUserImgfromFunc(int (*func)(void*), void* arg, uint64 img_start, uint64 img_end, char* name = (char*)"");
```
此外，我们也基于这样的逻辑对于调度器实现了很多增强功能，比如让一个进程休息、强行杀死一个进程、立刻运行一个进程（高优先级）、退出一个进程等。相关函数或者功能的实现逻辑均可在代码中找到，相关注释也都清楚地解释了具体逻辑，这里不再赘述了。<br />By：谢骏鑫
